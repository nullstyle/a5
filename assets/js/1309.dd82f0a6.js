"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1309],{1309:(e,t,a)=>{a.d(t,{A:()=>E});var n=a(688);class i{static get componentName(){return Object.prototype.hasOwnProperty.call(this,"extensionName")?this.extensionName:""}constructor(e){e&&(this.opts=e)}equals(e){return this===e||this.constructor===e.constructor&&(0,n.b)(this.opts,e.opts,1)}getShaders(e){return null}getSubLayerProps(e){const{defaultProps:t}=e.constructor,a={updateTriggers:{}};for(const n in t)if(n in this.props){const e=t[n],i=this.props[n];a[n]=i,e&&"accessor"===e.type&&(a.updateTriggers[n]=this.props.updateTriggers[n],"function"==typeof i&&(a[n]=this.getSubLayerAccessor(i)))}return a}initializeState(e,t){}updateState(e,t){}onNeedsRedraw(e){}getNeedsPickingBuffer(e){return!1}draw(e,t){}finalizeState(e,t){}}i.defaultProps={},i.extensionName="LayerExtension";const r=i;var s=a(8277);const o="uniform dataFilterUniforms {\n  bool useSoftMargin;\n  bool enabled;\n  bool transformSize;\n  bool transformColor;\n#ifdef DATAFILTER_TYPE\n  DATAFILTER_TYPE min;\n  DATAFILTER_TYPE softMin;\n  DATAFILTER_TYPE softMax;\n  DATAFILTER_TYPE max;\n#ifdef DATAFILTER_DOUBLE\n  DATAFILTER_TYPE min64High;\n  DATAFILTER_TYPE max64High;\n#endif\n#endif\n#ifdef DATACATEGORY_TYPE\n  highp uvec4 categoryBitMask;\n#endif\n} dataFilter;\n",l=`\n${o}\n\n#ifdef DATAFILTER_TYPE\n  in DATAFILTER_TYPE filterValues;\n#ifdef DATAFILTER_DOUBLE\n  in DATAFILTER_TYPE filterValues64Low;\n#endif\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  in DATACATEGORY_TYPE filterCategoryValues;\n#endif\n\nout float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\n\n#ifdef DATAFILTER_TYPE\n  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n    if (dataFilter.useSoftMargin) {\n      // smoothstep results are undefined if edge0 \u2265 edge1\n      // Fallback to ignore filterSoftRange if it is truncated by filterRange\n      DATAFILTER_TYPE leftInRange = mix(\n        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),\n        step(dataFilter.min, valueFromMin),\n        step(dataFilter.softMin, dataFilter.min)\n      );\n      DATAFILTER_TYPE rightInRange = mix(\n        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),\n        step(valueFromMax, dataFilter.max),\n        step(dataFilter.max, dataFilter.softMax)\n      );\n      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)\n      );\n    }\n  }\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {\n    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask\n    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];\n    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks\n    uvec2 dataFilter_masks = uvec2(\n      dataFilter.categoryBitMask[category.x / 32u],\n      dataFilter.categoryBitMask[category.y / 32u + 2u]\n    );\n    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks\n    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;\n    #else // Four 32-bit masks\n    uvec4 dataFilter_masks = dataFilter.categoryBitMask;\n    #endif\n\n    // Shift mask and extract relevant bits\n    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);\n    dataFilter_bits &= 1u;\n\n    #if DATACATEGORY_CHANNELS == 1\n    if(dataFilter_bits == 0u) dataFilter_value = 0.0;\n    #else\n    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;\n    #endif\n  }\n#endif\n\n`,f=`\n${o}\n\nin float dataFilter_value;\n\n`;function d(e){if(!e||!("extensions"in e))return{};const{filterRange:t=[-1,1],filterEnabled:a=!0,filterTransformSize:n=!0,filterTransformColor:i=!0,categoryBitMask:r}=e,s=e.filterSoftRange||t;return{...Number.isFinite(t[0])?{min:t[0],softMin:s[0],softMax:s[1],max:t[1]}:{min:t.map((e=>e[0])),softMin:s.map((e=>e[0])),softMax:s.map((e=>e[1])),max:t.map((e=>e[1]))},enabled:a,useSoftMargin:Boolean(e.filterSoftRange),transformSize:a&&n,transformColor:a&&i,...r&&{categoryBitMask:r}}}const c={"vs:#main-start":"\n    dataFilter_value = 1.0;\n    if (dataFilter.enabled) {\n      #ifdef DATAFILTER_TYPE\n        #ifdef DATAFILTER_DOUBLE\n          dataFilter_setValue(\n            filterValues - dataFilter.min64High + filterValues64Low,\n            filterValues - dataFilter.max64High + filterValues64Low\n          );\n        #else\n          dataFilter_setValue(filterValues, filterValues);\n        #endif\n      #endif\n\n      #ifdef DATACATEGORY_TYPE\n        dataFilter_setCategoryValue(filterCategoryValues);\n      #endif\n    }\n  ","vs:#main-end":"\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  ","vs:DECKGL_FILTER_SIZE":"\n    if (dataFilter.transformSize) {\n      size = size * dataFilter_value;\n    }\n  ","fs:DECKGL_FILTER_COLOR":"\n    if (dataFilter_value == 0.0) discard;\n    if (dataFilter.transformColor) {\n      color.a *= dataFilter_value;\n    }\n  "};function u(e){const{categorySize:t,filterSize:a,fp64:n}=e,i={useSoftMargin:"i32",enabled:"i32",transformSize:"i32",transformColor:"i32"};if(a){const e=1===a?"f32":`vec${a}<f32>`;i.min=e,i.softMin=e,i.softMax=e,i.max=e,n&&(i.min64High=e,i.max64High=e)}return t&&(i.categoryBitMask="vec4<i32>"),i}const g={name:"dataFilter",vs:l,fs:f,inject:c,getUniforms:d,uniformTypesFromOptions:u},m={name:"dataFilter",vs:l,fs:f,inject:c,getUniforms:function(e){if(!e||!("extensions"in e))return{};const t=d(e);if(Number.isFinite(t.min)){const e=Math.fround(t.min);t.min-=e,t.softMin-=e,t.min64High=e;const a=Math.fround(t.max);t.max-=a,t.softMax-=a,t.max64High=a}else{const e=t.min.map(Math.fround);t.min=t.min.map(((t,a)=>t-e[a])),t.softMin=t.softMin.map(((t,a)=>t-e[a])),t.min64High=e;const a=t.max.map(Math.fround);t.max=t.max.map(((e,t)=>e-a[t])),t.softMax=t.softMax.map(((e,t)=>e-a[t])),t.max64High=a}return t},uniformTypesFromOptions:u};var T=a(5597);const p=["float32-renderable-webgl","texture-blend-float-webgl"];const F={blend:!0,blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one",blendColorOperation:"add",blendAlphaOperation:"add",depthCompare:"never"},A={categorySize:0,filterSize:1,fp64:!1,countItems:!1},h={1:"uint",2:"uvec2",3:"uvec3",4:"uvec4"},v={1:"float",2:"vec2",3:"vec3",4:"vec4"};class _ extends r{constructor(e={}){super({...A,...e})}getShaders(e){const{categorySize:t,filterSize:a,fp64:n}=e.opts,i={};t&&(i.DATACATEGORY_TYPE=h[t],i.DATACATEGORY_CHANNELS=t),a&&(i.DATAFILTER_TYPE=v[a],i.DATAFILTER_DOUBLE=Boolean(n));const r=n?m:g;return r.uniformTypes=r.uniformTypesFromOptions(e.opts),{modules:[r],defines:i}}initializeState(e,t){const a=this.getAttributeManager(),{categorySize:n,filterSize:i,fp64:r}=t.opts;a&&(i&&a.add({filterValues:{size:i,type:r?"float64":"float32",stepMode:"dynamic",accessor:"getFilterValue"}}),n&&a.add({filterCategoryValues:{size:n,stepMode:"dynamic",accessor:"getFilterCategory",type:"uint32",transform:1===n?e=>t._getCategoryKey.call(this,e,0):e=>e.map(((e,a)=>t._getCategoryKey.call(this,e,a)))}}));const{device:s}=this.context;if(a&&t.opts.countItems){const e=function(e){return p.every((t=>e.features.has(t)))}(s);a.add({filterVertexIndices:{size:e?1:2,vertexOffset:1,type:"unorm8",accessor:(t,{index:a})=>{const n=t&&t.__source?t.__source.index:a;return e?(n+1)%255:[(n+1)%255,Math.floor(n/255)%255]},shaderAttributes:{filterPrevIndices:{vertexOffset:0},filterIndices:{vertexOffset:1}}}});const n=function(e,t){return t?e.createFramebuffer({width:1,height:1,colorAttachments:[e.createTexture({format:"rgba32float",mipmaps:!1})]}):e.createFramebuffer({width:256,height:64,colorAttachments:[e.createTexture({format:"rgba8unorm",mipmaps:!1})]})}(s,e),i=function(e,t,a,n){return a.defines.NON_INSTANCED_MODEL=1,n&&(a.defines.FLOAT_TARGET=1),new T.K(e,{id:"data-filter-aggregation-model",vertexCount:1,isInstanced:!1,topology:"point-list",disableWarnings:!0,vs:"#version 300 es\n#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  in float filterIndices;\n  in float filterPrevIndices;\n#else\n  in vec2 filterIndices;\n  in vec2 filterPrevIndices;\n#endif\n\nout vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n",fs:"#version 300 es\n#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  fragColor = vColor;\n}\n",bufferLayout:t,...a})}(s,a.getBufferLayouts({isInstanced:!1}),t.getShaders.call(this,t),e);this.setState({filterFBO:n,filterModel:i})}}updateState({props:e,oldProps:t,changeFlags:a},i){const r=this.getAttributeManager(),{categorySize:s}=i.opts;if(this.state.filterModel){const a=r.attributes.filterValues?.needsUpdate()||r.attributes.filterCategoryValues?.needsUpdate()||e.filterEnabled!==t.filterEnabled||e.filterRange!==t.filterRange||e.filterSoftRange!==t.filterSoftRange||e.filterCategories!==t.filterCategories;a&&this.setState({filterNeedsUpdate:a})}if(r?.attributes.filterCategoryValues){(r.attributes.filterCategoryValues.needsUpdate()||!(0,n.b)(e.filterCategories,t.filterCategories,2))&&this.setState({categoryBitMask:null});a.dataChanged&&(this.setState({categoryMap:Array(s).fill(0).map((()=>({})))}),r.attributes.filterCategoryValues.setNeedsUpdate("categoryMap"))}}draw(e,t){const a=this.state.filterFBO,n=this.state.filterModel,i=this.state.filterNeedsUpdate;this.state.categoryBitMask||t._updateCategoryBitMask.call(this,e,t);const{onFilteredItemsChange:r,extensions:s,filterEnabled:o,filterRange:l,filterSoftRange:f,filterTransformSize:d,filterTransformColor:c,filterCategories:u}=this.props,g={extensions:s,filterEnabled:o,filterRange:l,filterSoftRange:f,filterTransformSize:d,filterTransformColor:c,filterCategories:u};if(this.state.categoryBitMask&&(g.categoryBitMask=this.state.categoryBitMask),this.setShaderModuleProps({dataFilter:g}),i&&r&&n){const e=this.getAttributeManager(),{attributes:{filterValues:t,filterCategoryValues:i,filterVertexIndices:s}}=e;n.setVertexCount(this.getNumInstances());const o={...t?.getValue(),...i?.getValue(),...s?.getValue()};n.setAttributes(o),n.shaderInputs.setProps({dataFilter:g});const l=[0,0,a.width,a.height],f=n.device.beginRenderPass({id:"data-filter-aggregation",framebuffer:a,parameters:{viewport:l},clearColor:[0,0,0,0]});n.setParameters(F),n.draw(f),f.end();const d=n.device.readPixelsToArrayWebGL(a);let c=0;for(let a=0;a<d.length;a++)c+=d[a];r({id:this.id,count:c}),this.state.filterNeedsUpdate=!1}}finalizeState(){const e=this.state.filterFBO,t=this.state.filterModel;e?.destroy(),t?.destroy()}_updateCategoryBitMask(e,t){const{categorySize:a}=t.opts;if(!a)return;const{filterCategories:n}=this.props,i=new Uint32Array([0,0,0,0]),r=1===a?[n]:n,o=1===a?128:2===a?64:32;for(let l=0;l<r.length;l++){const e=r[l];for(const a of e){const e=t._getCategoryKey.call(this,a,l);if(e<o){i[l*(o/32)+Math.floor(e/32)]+=Math.pow(2,e%32)}else s.A.warn(`Exceeded maximum number of categories (${o})`)()}}this.state.categoryBitMask=i}_getCategoryKey(e,t){const a=this.state.categoryMap[t];return e in a||(a[e]=Object.keys(a).length),a[e]}}_.defaultProps={getFilterValue:{type:"accessor",value:0},getFilterCategory:{type:"accessor",value:0},onFilteredItemsChange:{type:"function",value:null,optional:!0},filterEnabled:!0,filterRange:[-1,1],filterSoftRange:null,filterCategories:[0],filterTransformSize:!0,filterTransformColor:!0},_.extensionName="DataFilterExtension";const E=_}}]);