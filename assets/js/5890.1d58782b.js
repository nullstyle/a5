"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5890],{203:(t,e,i)=>{i.d(e,{A:()=>a});var n=i(1729),o=i(8457),r=i(1829),s=i(6049);class a{constructor(t){this.indexStarts=[0],this.vertexStarts=[0],this.vertexCount=0,this.instanceCount=0;const{attributes:e={}}=t;this.typedArrayManager=o.A,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:i={},getGeometry:n,geometryBuffer:o,positionFormat:s,dataChanged:a,normalize:l=!0}=this.opts;if(this.data=e,this.getGeometry=n,this.positionSize=o&&o.size||("XY"===s?2:3),this.buffers=i,this.normalize=l,o&&((0,r.A)(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),l||(i.vertexPositions=o)),this.geometryBuffer=i.vertexPositions,Array.isArray(a))for(const r of a)this._rebuildGeometry(r);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?(0,n.I)(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:i,buffers:n,_attributeDefs:o,typedArrayManager:r}=this;for(const s in o)if(s in n)r.release(i[s]),i[s]=null;else{const n=o[s];n.copy=e,i[s]=r.allocate(i[s],t,n)}}_forEachGeometry(t,e,i){const{data:o,getGeometry:r}=this,{iterable:s,objectInfo:a}=(0,n.X)(o,e,i);for(const n of s){a.index++;t(r?r(n,a):null,a.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:i,instanceCount:n}=this;const{data:o,geometryBuffer:r}=this,{startRow:a=0,endRow:l=1/0}=t||{},c={};if(t||(e=[0],i=[0]),this.normalize||!r)this._forEachGeometry(((t,e)=>{const n=t&&this.normalizeGeometry(t);c[e]=n,i[e+1]=i[e]+(n?this.getGeometrySize(n):0)}),a,l),n=i[i.length-1];else if(i=o.startIndices,n=i[o.length]||0,ArrayBuffer.isView(r))n=n||r.length/this.positionSize;else if(r instanceof s.h){const t=4*this.positionSize;n=n||r.byteLength/t}else if(r.buffer){const t=r.stride||4*this.positionSize;n=n||r.buffer.byteLength/t}else if(r.value){const t=r.value,e=r.stride/t.BYTES_PER_ELEMENT||this.positionSize;n=n||t.length/e}this._allocate(n,Boolean(t)),this.indexStarts=e,this.vertexStarts=i,this.instanceCount=n;const g={};this._forEachGeometry(((t,o)=>{const r=c[o]||t;g.vertexStart=i[o],g.indexStart=e[o];const s=o<i.length-1?i[o+1]:n;g.geometrySize=s-i[o],g.geometryIndex=o,this.updateGeometryAttributes(r,g)}),a,l),this.vertexCount=e[e.length-1]}}},1341:(t,e,i)=>{i.d(e,{X:()=>n});const n="struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, phongMaterial.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n"},2114:(t,e,i)=>{i.d(e,{A:()=>m});var n=i(9777),o=i(2101),r=i(4411),s=i(6704),a=i(3391),l=i(5597),c=i(203),g=i(4520);class h extends c.A{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(t){return this.attributes[t]}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):null}normalizeGeometry(t){return this.normalize?function(t,e,i,n){let o;if(Array.isArray(t[0])){const i=t.length*e;o=new Array(i);for(let n=0;n<t.length;n++)for(let i=0;i<e;i++)o[n*e+i]=t[n][i]||0}else o=t;return i?(0,g.Mk)(o,{size:e,gridResolution:i}):n?(0,g.Iy)(o,{size:e}):o}(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}getGeometrySize(t){if(d(t)){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&d(t))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const i=this.attributes.segmentTypes,n=!!t&&this.isClosed(t),{vertexStart:o,geometrySize:r}=e;i.fill(0,o,o+r),n?(i[o]=4,i[o+r-2]=4):(i[o]+=1,i[o+r-2]+=2),i[o+r-1]=4}_updatePositions(t,e){const{positions:i}=this.attributes;if(!i||!t)return;const{vertexStart:n,geometrySize:o}=e,r=new Array(3);for(let s=n,a=0;a<o;s++,a++)this.getPointOnPath(t,a,r),i[3*s]=r[0],i[3*s+1]=r[1],i[3*s+2]=r[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,i=[]){const{positionSize:n}=this;e*n>=t.length&&(e+=1-t.length/n);const o=e*n;return i[0]=t[o],i[1]=t[o+1],i[2]=3===n&&t[o+2]||0,i}isClosed(t){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:e}=this,i=t.length-e;return t[0]===t[i]&&t[1]===t[i+1]&&(2===e||t[2]===t[i+2])}}function d(t){return Array.isArray(t[0])}const p="uniform pathUniforms {\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  float jointType;\n  float capType;\n  float miterLimit;\n  bool billboard;\n  highp int widthUnits;\n} path;\n",u={name:"path",vs:p,fs:p,uniformTypes:{widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",jointType:"f32",capType:"f32",miterLimit:"f32",billboard:"f32",widthUnits:"i32"}},f=[0,0,0,255],v={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:f},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},y={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class x extends n.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME path-layer-vertex-shader\nin vec2 positions;\nin float instanceTypes;\nin vec3 instanceStartPositions;\nin vec3 instanceEndPositions;\nin vec3 instanceLeftPositions;\nin vec3 instanceRightPositions;\nin vec3 instanceLeftPositions64Low;\nin vec3 instanceStartPositions64Low;\nin vec3 instanceEndPositions64Low;\nin vec3 instanceRightPositions64Low;\nin float instanceStrokeWidths;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nuniform float opacity;\nout vec4 vColor;\nout vec2 vCornerOffset;\nout float vMiterLength;\nout vec2 vPathPosition;\nout float vPathLength;\nout float vJointType;\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\nfloat flipIfTrue(bool flag) {\nreturn -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\nvec3 prevPoint, vec3 currPoint, vec3 nextPoint,\nvec2 width\n) {\nbool isEnd = positions.x > 0.0;\nfloat sideOfPath = positions.y;\nfloat isJoint = float(sideOfPath == 0.0);\nvec3 deltaA3 = (currPoint - prevPoint);\nvec3 deltaB3 = (nextPoint - currPoint);\nmat3 rotationMatrix;\nbool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);\nif (needsRotation) {\ndeltaA3 = deltaA3 * rotationMatrix;\ndeltaB3 = deltaB3 * rotationMatrix;\n}\nvec2 deltaA = deltaA3.xy / width;\nvec2 deltaB = deltaB3.xy / width;\nfloat lenA = length(deltaA);\nfloat lenB = length(deltaB);\nvec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\nvec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\nvec2 perpA = vec2(-dirA.y, dirA.x);\nvec2 perpB = vec2(-dirB.y, dirB.x);\nvec2 tangent = dirA + dirB;\ntangent = length(tangent) > 0. ? normalize(tangent) : perpA;\nvec2 miterVec = vec2(-tangent.y, tangent.x);\nvec2 dir = isEnd ? dirA : dirB;\nvec2 perp = isEnd ? perpA : perpB;\nfloat L = isEnd ? lenA : lenB;\nfloat sinHalfA = abs(dot(miterVec, perp));\nfloat cosHalfA = abs(dot(dirA, miterVec));\nfloat turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\nfloat cornerPosition = sideOfPath * turnDirection;\nfloat miterSize = 1.0 / max(sinHalfA, EPSILON);\nmiterSize = mix(\nmin(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\nmiterSize,\nstep(0.0, cornerPosition)\n);\nvec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n* (sideOfPath + isJoint * turnDirection);\nbool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\nbool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\nbool isCap = isStartCap || isEndCap;\nif (isCap) {\noffsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);\nvJointType = path.capType;\n} else {\nvJointType = path.jointType;\n}\nvPathLength = L;\nvCornerOffset = offsetVec;\nvMiterLength = dot(vCornerOffset, miterVec * turnDirection);\nvMiterLength = isCap ? isJoint : vMiterLength;\nvec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\nvPathPosition = vec2(\ndot(offsetFromStartOfPath, perp),\ndot(offsetFromStartOfPath, dir)\n);\ngeometry.uv = vPathPosition;\nfloat isValid = step(instanceTypes, 3.5);\nvec3 offset = vec3(offsetVec * width * isValid, 0.0);\nif (needsRotation) {\noffset = rotationMatrix * offset;\n}\nreturn offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\nif (position.w < EPSILON) {\nfloat r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\nposition = refPosition + (position - refPosition) * r;\n}\n}\nvoid main() {\ngeometry.pickingColor = instancePickingColors;\nvColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);\nfloat isEnd = positions.x;\nvec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\nvec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\nvec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\nvec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\nvec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\nvec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\ngeometry.worldPosition = currPosition;\nvec2 widthPixels = vec2(clamp(\nproject_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),\npath.widthMinPixels, path.widthMaxPixels) / 2.0);\nvec3 width;\nif (path.billboard) {\nvec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\nvec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\nvec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\nclipLine(prevPositionScreen, currPositionScreen);\nclipLine(nextPositionScreen, currPositionScreen);\nclipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\nwidth = vec3(widthPixels, 0.0);\nDECKGL_FILTER_SIZE(width, geometry);\nvec3 offset = getLineJoinOffset(\nprevPositionScreen.xyz / prevPositionScreen.w,\ncurrPositionScreen.xyz / currPositionScreen.w,\nnextPositionScreen.xyz / nextPositionScreen.w,\nproject_pixel_size_to_clipspace(width.xy)\n);\nDECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\ngl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n} else {\nprevPosition = project_position(prevPosition, prevPosition64Low);\ncurrPosition = project_position(currPosition, currPosition64Low);\nnextPosition = project_position(nextPosition, nextPosition64Low);\nwidth = vec3(project_pixel_size(widthPixels), 0.0);\nDECKGL_FILTER_SIZE(width, geometry);\nvec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\ngeometry.position = vec4(currPosition + offset, 1.0);\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME path-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 vCornerOffset;\nin float vMiterLength;\nin vec2 vPathPosition;\nin float vPathLength;\nin float vJointType;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = vPathPosition;\nif (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\nif (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\ndiscard;\n}\nif (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {\ndiscard;\n}\n}\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[o.A,r.A,u]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){const t=!0;this.getAttributeManager().addInstanced({vertexPositions:{size:3,vertexOffset:1,type:"float64",fp64:this.use64bitPositions(),transition:y,accessor:"getPath",update:this.calculatePositions,noAlloc:t,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:"uint8",update:this.calculateSegmentTypes,noAlloc:t},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:y,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",accessor:"getColor",transition:y,defaultValue:f},instancePickingColors:{size:4,type:"uint8",accessor:(t,{index:e,target:i})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,i)}}),this.setState({pathTesselator:new h({fp64:this.use64bitPositions()})})}updateState(t){super.updateState(t);const{props:e,changeFlags:i}=t,n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,o=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:o.getPath,buffers:o,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),i.dataChanged||n.invalidateAll()}i.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),n.invalidateAll())}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,n=this.props.data;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const e=this.props.data;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else super.disablePickingIndex(t)}draw({uniforms:t}){const{jointRounded:e,capRounded:i,billboard:n,miterLimit:o,widthUnits:r,widthScale:a,widthMinPixels:l,widthMaxPixels:c}=this.props,g=this.state.model,h={jointType:Number(e),capType:Number(i),billboard:n,widthUnits:s.p5[r],widthScale:a,miterLimit:o,widthMinPixels:l,widthMaxPixels:c};g.shaderInputs.setProps({path:h}),g.draw(this.context.renderPass)}_getModel(){return new l.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new a.V({topology:"triangle-list",attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}x.defaultProps=v,x.layerName="PathLayer";const m=x},2986:(t,e,i)=>{i.d(e,{J:()=>s});var n=i(6875),o=i(5248),r=i(1341);const s={props:{},name:"gouraudMaterial",vs:o.l.replace("phongMaterial","gouraudMaterial"),fs:o.X.replace("phongMaterial","gouraudMaterial"),source:r.X.replaceAll("phongMaterial","gouraudMaterial"),defines:{LIGHTING_VERTEX:1},dependencies:[n.x],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(t){const e={...t};return e.specularColor&&(e.specularColor=e.specularColor.map((t=>t/255))),{...s.defaultUniforms,...e}}}},4402:(t,e,i)=>{i.d(e,{A:()=>l});var n=i(9777),o=i(7277),r=i(5801),s=i(8427);class a extends n.A{get isComposite(){return!0}get isDrawable(){return!1}get isLoaded(){return super.isLoaded&&this.getSubLayers().every((t=>t.isLoaded))}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(t){}setState(t){super.setState(t),this.setNeedsUpdate()}getPickingInfo({info:t}){const{object:e}=t;return e&&e.__source&&e.__source.parent&&e.__source.parent.id===this.id?(t.object=e.__source.object,t.index=e.__source.index,t):t}filterSubLayer(t){return!0}shouldRenderSubLayer(t,e){return e&&e.length}getSubLayerClass(t,e){const{_subLayerProps:i}=this.props;return i&&i[t]&&i[t].type||e}getSubLayerRow(t,e,i){return t.__source={parent:this,object:e,index:i},t}getSubLayerAccessor(t){if("function"==typeof t){const e={index:-1,data:this.props.data,target:[]};return(i,n)=>i&&i.__source?(e.index=i.__source.index,t(i.__source.object,e)):t(i,n)}return t}getSubLayerProps(t={}){const{opacity:e,pickable:i,visible:n,parameters:o,getPolygonOffset:r,highlightedObjectIndex:a,autoHighlight:l,highlightColor:c,coordinateSystem:g,coordinateOrigin:h,wrapLongitude:d,positionFormat:p,modelMatrix:u,extensions:f,fetch:v,operation:y,_subLayerProps:x}=this.props,m={id:"",updateTriggers:{},opacity:e,pickable:i,visible:n,parameters:o,getPolygonOffset:r,highlightedObjectIndex:a,autoHighlight:l,highlightColor:c,coordinateSystem:g,coordinateOrigin:h,wrapLongitude:d,positionFormat:p,modelMatrix:u,extensions:f,fetch:v,operation:y},L=x&&t.id&&x[t.id],P=L&&L.updateTriggers,_=t.id||"sublayer";if(L){const e=this.props[s.fW],i=t.type?t.type._propTypes:{};for(const t in L){const n=i[t]||e[t];n&&"accessor"===n.type&&(L[t]=this.getSubLayerAccessor(L[t]))}}Object.assign(m,t,L),m.id=`${this.props.id}-${_}`,m.updateTriggers={all:this.props.updateTriggers?.all,...t.updateTriggers,...P};for(const s of f){const t=s.getSubLayerProps.call(this,s);t&&Object.assign(m,t,{updateTriggers:Object.assign(m.updateTriggers,t.updateTriggers)})}return m}_updateAutoHighlight(t){for(const e of this.getSubLayers())e.updateAutoHighlight(t)}_getAttributeManager(){return null}_postUpdate(t,e){let i=this.internalState.subLayers;const n=!i||this.needsUpdate();if(n){const t=this.renderLayers();i=(0,r.B)(t,Boolean),this.internalState.subLayers=i}(0,o.A)("compositeLayer.renderLayers",this,n,i);for(const o of i)o.parent=this}}a.layerName="CompositeLayer";const l=a},4520:(t,e,i)=>{i.d(e,{rJ:()=>n,wk:()=>u,Eg:()=>_,Mk:()=>h,Iy:()=>P,UD:()=>o});const n={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function o(t,e,i={}){const n=function(t,e={}){return Math.sign(function(t,e={}){const{start:i=0,end:n=t.length,plane:o="xy"}=e,s=e.size||2;let a=0;const l=r[o[0]],c=r[o[1]];for(let r=i,g=n-s;r<n;r+=s)a+=(t[r+l]-t[g+l])*(t[r+c]+t[g+c]),g=r;return a/2}(t,e))}(t,i);return n!==e&&(function(t,e){const{start:i=0,end:n=t.length,size:o=2}=e,r=(n-i)/o,s=Math.floor(r/2);for(let a=0;a<s;++a){const e=i+a*o,n=i+(r-1-a)*o;for(let i=0;i<o;++i){const o=t[e+i];t[e+i]=t[n+i],t[n+i]=o}}}(t,i),!0)}const r={x:0,y:1,z:2};function s(t,e,i,n,o=[]){let r,s;if(8&i)r=(n[3]-t[1])/(e[1]-t[1]),s=3;else if(4&i)r=(n[1]-t[1])/(e[1]-t[1]),s=1;else if(2&i)r=(n[2]-t[0])/(e[0]-t[0]),s=2;else{if(!(1&i))return null;r=(n[0]-t[0])/(e[0]-t[0]),s=0}for(let a=0;a<t.length;a++)o[a]=(1&s)===a?n[s]:r*(e[a]-t[a])+t[a];return o}function a(t,e){let i=0;return t[0]<e[0]?i|=1:t[0]>e[2]&&(i|=2),t[1]<e[1]?i|=4:t[1]>e[3]&&(i|=8),i}function l(t,e){const i=e.length,n=t.length;if(n>0){let o=!0;for(let r=0;r<i;r++)if(t[n-i+r]!==e[r]){o=!1;break}if(o)return!1}for(let o=0;o<i;o++)t[n+o]=e[o];return!0}function c(t,e){const i=e.length;for(let n=0;n<i;n++)t[n]=e[n]}function g(t,e,i,n,o=[]){const r=n+e*i;for(let s=0;s<i;s++)o[s]=t[r+s];return o}function h(t,e){const{size:i=2,broken:n=!1,gridResolution:o=10,gridOffset:r=[0,0],startIndex:h=0,endIndex:d=t.length}=e||{},p=(d-h)/i;let u=[];const f=[u],x=g(t,0,i,h);let m,L;const P=v(x,o,r,[]),_=[];l(u,x);for(let v=1;v<p;v++){for(m=g(t,v,i,h,m),L=a(m,P);L;){s(x,m,L,P,_);const t=a(_,P);t&&(s(x,_,t,P,_),L=t),l(u,_),c(x,_),y(P,o,L),n&&u.length>i&&(u=[],f.push(u),l(u,x)),L=a(m,P)}l(u,m),c(x,m)}return n?f:f[0]}const d=0,p=1;function u(t,e=null,i){if(!t.length)return[];const{size:n=2,gridResolution:o=10,gridOffset:r=[0,0],edgeTypes:s=!1}=i||{},l=[],c=[{pos:t,types:s?new Array(t.length/n).fill(p):null,holes:e||[]}],g=[[],[]];let h=[];for(;c.length;){const{pos:t,types:e,holes:i}=c.shift();x(t,n,i[0]||t.length,g),h=v(g[0],o,r,h);const d=a(g[1],h);if(d){let o=f(t,e,n,0,i[0]||t.length,h,d);const r={pos:o[0].pos,types:o[0].types,holes:[]},a={pos:o[1].pos,types:o[1].types,holes:[]};c.push(r,a);for(let l=0;l<i.length;l++)o=f(t,e,n,i[l],i[l+1]||t.length,h,d),o[0]&&(r.holes.push(r.pos.length),r.pos=m(r.pos,o[0].pos),s&&(r.types=m(r.types,o[0].types))),o[1]&&(a.holes.push(a.pos.length),a.pos=m(a.pos,o[1].pos),s&&(a.types=m(a.types,o[1].types)))}else{const n={positions:t};s&&(n.edgeTypes=e),i.length&&(n.holeIndices=i),l.push(n)}}return l}function f(t,e,i,n,o,r,a){const h=(o-n)/i,p=[],u=[],f=[],v=[],y=[];let x,m,L;const P=g(t,h-1,i,n);let _=Math.sign(8&a?P[1]-r[3]:P[0]-r[2]),C=e&&e[h-1],w=0,b=0;for(let S=0;S<h;S++)x=g(t,S,i,n,x),m=Math.sign(8&a?x[1]-r[3]:x[0]-r[2]),L=e&&e[n/i+S],m&&_&&_!==m&&(s(P,x,a,r,y),l(p,y)&&f.push(C),l(u,y)&&v.push(C)),m<=0?(l(p,x)&&f.push(L),w-=m):f.length&&(f[f.length-1]=d),m>=0?(l(u,x)&&v.push(L),b+=m):v.length&&(v[v.length-1]=d),c(P,x),_=m,C=L;return[w?{pos:p,types:e&&f}:null,b?{pos:u,types:e&&v}:null]}function v(t,e,i,n){const o=Math.floor((t[0]-i[0])/e)*e+i[0],r=Math.floor((t[1]-i[1])/e)*e+i[1];return n[0]=o,n[1]=r,n[2]=o+e,n[3]=r+e,n}function y(t,e,i){8&i?(t[1]+=e,t[3]+=e):4&i?(t[1]-=e,t[3]-=e):2&i?(t[0]+=e,t[2]+=e):1&i&&(t[0]-=e,t[2]-=e)}function x(t,e,i,n){let o=1/0,r=-1/0,s=1/0,a=-1/0;for(let l=0;l<i;l+=e){const e=t[l],i=t[l+1];o=e<o?e:o,r=e>r?e:r,s=i<s?i:s,a=i>a?i:a}return n[0][0]=o,n[0][1]=s,n[1][0]=r,n[1][1]=a,n}function m(t,e){for(let i=0;i<e.length;i++)t.push(e[i]);return t}const L=85.051129;function P(t,e){const{size:i=2,startIndex:n=0,endIndex:o=t.length,normalize:r=!0}=e||{},s=t.slice(n,o);b(s,i,0,o-n);const a=h(s,{size:i,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(r)for(const l of a)S(l,i);return a}function _(t,e=null,i){const{size:n=2,normalize:o=!0,edgeTypes:r=!1}=i||{};e=e||[];const s=[],a=[];let l=0,c=0;for(let h=0;h<=e.length;h++){const o=e[h]||t.length,r=c,g=C(t,n,l,o);for(let e=g;e<o;e++)s[c++]=t[e];for(let e=l;e<g;e++)s[c++]=t[e];b(s,n,r,c),w(s,n,r,c,i?.maxLatitude),l=o,a[h]=c}a.pop();const g=u(s,a,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:r});if(o)for(const h of g)S(h.positions,n);return g}function C(t,e,i,n){let o=-1,r=-1;for(let s=i+1;s<n;s+=e){const e=Math.abs(t[s]);e>o&&(o=e,r=s-1)}return r}function w(t,e,i,n,o=L){const r=t[i],s=t[n-e];if(Math.abs(r-s)>180){const n=g(t,0,e,i);n[0]+=360*Math.round((s-r)/360),l(t,n),n[1]=Math.sign(n[1])*o,l(t,n),n[0]=r,l(t,n)}}function b(t,e,i,n){let o,r=t[0];for(let s=i;s<n;s+=e){o=t[s];const e=o-r;(e>180||e<-180)&&(o-=360*Math.round(e/360)),t[s]=r=o}}function S(t,e){let i;const n=t.length/e;for(let r=0;r<n&&(i=t[r*e],(i+180)%360==0);r++);const o=360*-Math.round(i/360);if(0!==o)for(let r=0;r<n;r++)t[r*e]+=o}},5248:(t,e,i)=>{i.d(e,{X:()=>n,l:()=>o});const n="uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n",o="uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n"},5890:(t,e,i)=>{i.d(e,{A:()=>j});var n=i(4402),o=i(8277),r=i(1729),s=i(9777),a=i(2101),l=i(4411),c=i(6704),g=i(5597),h=i(3391),d=i(2986),p=i(6570),u=i(4520);const f=u.rJ.CLOCKWISE,v=u.rJ.COUNTER_CLOCKWISE,y={isClosed:!0};function x(t){return"positions"in t?t.positions:t}function m(t){return"holeIndices"in t?t.holeIndices:null}function L(t,e,i,n,o){let r=e;const s=i.length;for(let a=0;a<s;a++)for(let e=0;e<n;e++)t[r++]=i[a][e]||0;if(!function(t){const e=t[0],i=t[t.length-1];return e[0]===i[0]&&e[1]===i[1]&&e[2]===i[2]}(i))for(let a=0;a<n;a++)t[r++]=i[0][a]||0;return y.start=e,y.end=r,y.size=n,(0,u.UD)(t,o,y),r}function P(t,e,i,n,o=0,r,s){const a=(r=r||i.length)-o;if(a<=0)return e;let l=e;for(let c=0;c<a;c++)t[l++]=i[o+c];if(!function(t,e,i,n){for(let o=0;o<e;o++)if(t[i+o]!==t[n-e+o])return!1;return!0}(i,n,o,r))for(let c=0;c<n;c++)t[l++]=i[o+c];return y.start=e,y.end=l,y.size=n,(0,u.UD)(t,s,y),l}function _(t,e){!function(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}(t);const i=[],n=[];if("positions"in t){const{positions:o,holeIndices:r}=t;if(r){let t=0;for(let s=0;s<=r.length;s++)t=P(i,t,o,e,r[s-1],r[s],0===s?f:v),n.push(t);return n.pop(),{positions:i,holeIndices:n}}t=o}if(!function(t){return Array.isArray(t[0])}(t))return P(i,0,t,e,0,i.length,f),i;if(!function(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}(t)){let o=0;for(const[r,s]of t.entries())o=L(i,o,s,e,0===r?f:v),n.push(o);return n.pop(),{positions:i,holeIndices:n}}return L(i,0,t,e,f),i}function C(t,e,i){const n=t.length/3;let o=0;for(let r=0;r<n;r++){const s=(r+1)%n;o+=t[3*r+e]*t[3*s+i],o-=t[3*s+e]*t[3*r+i]}return Math.abs(o/2)}function w(t,e,i,n){const o=t.length/3;for(let r=0;r<o;r++){const o=3*r,s=t[o+0],a=t[o+1],l=t[o+2];t[o+e]=s,t[o+i]=a,t[o+n]=l}}var b=i(203);class S extends b.A{constructor(t){const{fp64:e,IndexType:i=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint16Array,size:1},indices:{type:i,size:1}}})}get(t){const{attributes:e}=this;return"indices"===t?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);const e=this.buffers.indices;if(e)this.vertexCount=(e.value||e).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(t){if(this.normalize){const e=_(t,this.positionSize);return this.opts.resolution?(0,u.wk)(x(e),m(e),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?(0,u.Eg)(x(e),m(e),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):e}return t}getGeometrySize(t){if(A(t)){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}return x(t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):null}updateGeometryAttributes(t,e){if(t&&A(t))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t,e.indexStart=this.indexStarts[e.geometryIndex+1]}else{const i=t;this._updateIndices(i,e),this._updatePositions(i,e),this._updateVertexValid(i,e)}}_updateIndices(t,{geometryIndex:e,vertexStart:i,indexStart:n}){const{attributes:o,indexStarts:r,typedArrayManager:s}=this;let a=o.indices;if(!a||!t)return;let l=n;const c=function(t,e,i,n){let o=m(t);o&&(o=o.map((t=>t/e)));let r=x(t);const s=n&&3===e;if(i){const t=r.length;r=r.slice();const n=[];for(let o=0;o<t;o+=e){n[0]=r[o],n[1]=r[o+1],s&&(n[2]=r[o+2]);const t=i(n);r[o]=t[0],r[o+1]=t[1],s&&(r[o+2]=t[2])}}if(s){const t=C(r,0,1),e=C(r,0,2),n=C(r,1,2);if(!t&&!e&&!n)return[];t>e&&t>n||(e>n?(i||(r=r.slice()),w(r,0,2,1)):(i||(r=r.slice()),w(r,2,0,1)))}return p(r,o,e)}(t,this.positionSize,this.opts.preproject,this.opts.full3d);a=s.allocate(a,n+c.length,{copy:!0});for(let g=0;g<c.length;g++)a[l++]=c[g]+i;r[e+1]=n+c.length,o.indices=a}_updatePositions(t,{vertexStart:e,geometrySize:i}){const{attributes:{positions:n},positionSize:o}=this;if(!n||!t)return;const r=x(t);for(let s=e,a=0;a<i;s++,a++){const t=r[a*o],e=r[a*o+1],i=o>2?r[a*o+2]:0;n[3*s]=t,n[3*s+1]=e,n[3*s+2]=i}}_updateVertexValid(t,{vertexStart:e,geometrySize:i}){const{positionSize:n}=this,o=this.attributes.vertexValid,r=t&&m(t);if(t&&t.edgeTypes?o.set(t.edgeTypes,e):o.fill(1,e,e+i),r)for(let s=0;s<r.length;s++)o[e+r[s]/n-1]=0;o[e+i-1]=0}}function A(t){return Array.isArray(t)&&t.length>0&&!Number.isFinite(t[0])}const T="uniform solidPolygonUniforms {\n  bool extruded;\n  bool isWireframe;\n  float elevationScale;\n} solidPolygon;\n",E={name:"solidPolygon",vs:T,fs:T,uniformTypes:{extruded:"f32",isWireframe:"f32",elevationScale:"f32"}},I="in vec4 fillColors;\nin vec4 lineColors;\nin vec3 pickingColors;\nout vec4 vColor;\nstruct PolygonProps {\nvec3 positions;\nvec3 positions64Low;\nvec3 normal;\nfloat elevations;\n};\nvec3 project_offset_normal(vec3 vector) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\nproject.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\nreturn normalize(vector * project.commonUnitsPerWorldUnit);\n}\nreturn project_normal(vector);\n}\nvoid calculatePosition(PolygonProps props) {\nvec3 pos = props.positions;\nvec3 pos64Low = props.positions64Low;\nvec3 normal = props.normal;\nvec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;\ngeometry.worldPosition = props.positions;\ngeometry.pickingColor = pickingColors;\nif (solidPolygon.extruded) {\npos.z += props.elevations * solidPolygon.elevationScale;\n}\ngl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nif (solidPolygon.extruded) {\n#ifdef IS_SIDE_VERTEX\nnormal = project_offset_normal(normal);\n#else\nnormal = project_normal(normal);\n#endif\ngeometry.normal = normal;\nvec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, colors.a * layer.opacity);\n} else {\nvColor = vec4(colors.rgb, colors.a * layer.opacity);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",z=`#version 300 es\n#define SHADER_NAME solid-polygon-layer-vertex-shader\nin vec3 vertexPositions;\nin vec3 vertexPositions64Low;\nin float elevations;\n${I}\nvoid main(void) {\nPolygonProps props;\nprops.positions = vertexPositions;\nprops.positions64Low = vertexPositions64Low;\nprops.elevations = elevations;\nprops.normal = vec3(0.0, 0.0, 1.0);\ncalculatePosition(props);\n}\n`,M=`#version 300 es\n#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\nin vec2 positions;\nin vec3 vertexPositions;\nin vec3 nextVertexPositions;\nin vec3 vertexPositions64Low;\nin vec3 nextVertexPositions64Low;\nin float elevations;\nin float instanceVertexValid;\n${I}\nvoid main(void) {\nif(instanceVertexValid < 0.5){\ngl_Position = vec4(0.);\nreturn;\n}\nPolygonProps props;\nvec3 pos;\nvec3 pos64Low;\nvec3 nextPos;\nvec3 nextPos64Low;\n#if RING_WINDING_ORDER_CW == 1\npos = vertexPositions;\npos64Low = vertexPositions64Low;\nnextPos = nextVertexPositions;\nnextPos64Low = nextVertexPositions64Low;\n#else\npos = nextVertexPositions;\npos64Low = nextVertexPositions64Low;\nnextPos = vertexPositions;\nnextPos64Low = vertexPositions64Low;\n#endif\nprops.positions = mix(pos, nextPos, positions.x);\nprops.positions64Low = mix(pos64Low, nextPos64Low, positions.x);\nprops.normal = vec3(\npos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),\nnextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),\n0.0);\nprops.elevations = elevations * positions.y;\ncalculatePosition(props);\n}\n`,R=[0,0,0,255],O={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:R},getLineColor:{type:"accessor",value:R},material:!0},D={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class G extends s.A{getShaders(t){return super.getShaders({vs:"top"===t?z:M,fs:"#version 300 es\n#define SHADER_NAME solid-polygon-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\ngeometry.uv = vec2(0.);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[a.A,d.J,l.A,E]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){const{viewport:t}=this.context;let{coordinateSystem:e}=this.props;const{_full3d:i}=this.props;let n;t.isGeospatial&&e===c.rf.DEFAULT&&(e=c.rf.LNGLAT),e===c.rf.LNGLAT&&(n=i?t.projectPosition.bind(t):t.projectFlat.bind(t)),this.setState({numInstances:0,polygonTesselator:new S({preproject:n,fp64:this.use64bitPositions(),IndexType:Uint32Array})});const o=this.getAttributeManager(),r=!0;o.remove(["instancePickingColors"]),o.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:r},vertexPositions:{size:3,type:"float64",stepMode:"dynamic",fp64:this.use64bitPositions(),transition:D,accessor:"getPolygon",update:this.calculatePositions,noAlloc:r,shaderAttributes:{nextVertexPositions:{vertexOffset:1}}},instanceVertexValid:{size:1,type:"uint16",stepMode:"instance",update:this.calculateVertexValid,noAlloc:r},elevations:{size:1,stepMode:"dynamic",transition:D,accessor:"getElevation"},fillColors:{size:this.props.colorFormat.length,type:"unorm8",stepMode:"dynamic",transition:D,accessor:"getFillColor",defaultValue:R},lineColors:{size:this.props.colorFormat.length,type:"unorm8",stepMode:"dynamic",transition:D,accessor:"getLineColor",defaultValue:R},pickingColors:{size:4,type:"uint8",stepMode:"dynamic",accessor:(t,{index:e,target:i})=>this.encodePickingColor(t&&t.__source?t.__source.index:e,i)}})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,n=this.props.data;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const e=this.props.data;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else super.disablePickingIndex(t)}draw({uniforms:t}){const{extruded:e,filled:i,wireframe:n,elevationScale:o}=this.props,{topModel:r,sideModel:s,wireframeModel:a,polygonTesselator:l}=this.state,c={extruded:Boolean(e),elevationScale:o,isWireframe:!1};a&&n&&(a.setInstanceCount(l.instanceCount-1),a.shaderInputs.setProps({solidPolygon:{...c,isWireframe:!0}}),a.draw(this.context.renderPass)),s&&i&&(s.setInstanceCount(l.instanceCount-1),s.shaderInputs.setProps({solidPolygon:c}),s.draw(this.context.renderPass)),r&&i&&(r.setVertexCount(l.vertexCount),r.shaderInputs.setProps({solidPolygon:c}),r.draw(this.context.renderPass))}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:i,changeFlags:n}=t,o=this.getAttributeManager();(n.extensionsChanged||e.filled!==i.filled||e.extruded!==i.extruded)&&(this.state.models?.forEach((t=>t.destroy())),this.setState(this._getModels()),o.invalidateAll())}updateGeometry({props:t,oldProps:e,changeFlags:i}){if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state,n=t.data.attributes||{};e.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:n.getPolygon,buffers:n,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:i.dataChanged,full3d:t._full3d}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),i.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(){const{id:t,filled:e,extruded:i}=this.props;let n,o,r;if(e){const e=this.getShaders("top");e.defines.NON_INSTANCED_MODEL=1;const i=this.getAttributeManager().getBufferLayouts({isInstanced:!1});n=new g.K(this.context.device,{...e,id:`${t}-top`,topology:"triangle-list",bufferLayout:i,isIndexed:!0,userData:{excludeAttributes:{instanceVertexValid:!0}}})}if(i){const e=this.getAttributeManager().getBufferLayouts({isInstanced:!0});o=new g.K(this.context.device,{...this.getShaders("side"),id:`${t}-side`,bufferLayout:e,geometry:new h.V({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,1,1,0,1])}}}),isInstanced:!0,userData:{excludeAttributes:{indices:!0}}}),r=new g.K(this.context.device,{...this.getShaders("side"),id:`${t}-wireframe`,bufferLayout:e,geometry:new h.V({topology:"line-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),isInstanced:!0,userData:{excludeAttributes:{indices:!0}}})}return{models:[o,r,n].filter(Boolean),topModel:n,sideModel:o,wireframeModel:r}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}}G.defaultProps=O,G.layerName="SolidPolygonLayer";const F=G;var N=i(2114);const V=[0,0,0,255],k={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:t=>t.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:V},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class B extends n.A{initializeState(){this.state={paths:[],pathsDiff:null},this.props.getLineDashArray&&o.A.removed("getLineDashArray","PathStyleExtension")()}updateState({changeFlags:t}){const e=t.dataChanged||t.updateTriggersChanged&&(t.updateTriggersChanged.all||t.updateTriggersChanged.getPolygon);if(e&&Array.isArray(t.dataChanged)){const e=this.state.paths.slice(),i=t.dataChanged.map((t=>function({data:t,getIndex:e,dataRange:i,replace:n}){const{startRow:o=0,endRow:r=1/0}=i,s=t.length;let a=s,l=s;for(let h=0;h<s;h++){const i=e(t[h]);if(a>h&&i>=o&&(a=h),i>=r){l=h;break}}let c=a;const g=l-a!==n.length?t.slice(l):void 0;for(let h=0;h<n.length;h++)t[c++]=n[h];if(g){for(let e=0;e<g.length;e++)t[c++]=g[e];t.length=c}return{startRow:a,endRow:a+n.length}}({data:e,getIndex:t=>t.__source.index,dataRange:t,replace:this._getPaths(t)})));this.setState({paths:e,pathsDiff:i})}else e&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(t={}){const{data:e,getPolygon:i,positionFormat:n,_normalize:o}=this.props,s=[],a="XY"===n?2:3,{startRow:l,endRow:c}=t,{iterable:g,objectInfo:h}=(0,r.X)(e,l,c);for(const r of g){h.index++;let t=i(r,h);o&&(t=_(t,a));const{holeIndices:e}=t,n=t.positions||t;if(e)for(let i=0;i<=e.length;i++){const t=n.slice(e[i-1]||0,e[i]||n.length);s.push(this.getSubLayerRow({path:t},r,h.index))}else s.push(this.getSubLayerRow({path:n},r,h.index))}return s}renderLayers(){const{data:t,_dataDiff:e,stroked:i,filled:n,extruded:o,wireframe:r,_normalize:s,_windingOrder:a,elevationScale:l,transitions:c,positionFormat:g}=this.props,{lineWidthUnits:h,lineWidthScale:d,lineWidthMinPixels:p,lineWidthMaxPixels:u,lineJointRounded:f,lineMiterLimit:v,lineDashJustified:y}=this.props,{getFillColor:x,getLineColor:m,getLineWidth:L,getLineDashArray:P,getElevation:_,getPolygon:C,updateTriggers:w,material:b}=this.props,{paths:S,pathsDiff:A}=this.state,T=this.getSubLayerClass("fill",F),E=this.getSubLayerClass("stroke",N.A),I=this.shouldRenderSubLayer("fill",S)&&new T({_dataDiff:e,extruded:o,elevationScale:l,filled:n,wireframe:r,_normalize:s,_windingOrder:a,getElevation:_,getFillColor:x,getLineColor:o&&r?m:V,material:b,transitions:c},this.getSubLayerProps({id:"fill",updateTriggers:w&&{getPolygon:w.getPolygon,getElevation:w.getElevation,getFillColor:w.getFillColor,lineColors:o&&r,getLineColor:w.getLineColor}}),{data:t,positionFormat:g,getPolygon:C});return[!o&&I,!o&&i&&this.shouldRenderSubLayer("stroke",S)&&new E({_dataDiff:A&&(()=>A),widthUnits:h,widthScale:d,widthMinPixels:p,widthMaxPixels:u,jointRounded:f,miterLimit:v,dashJustified:y,_pathType:"loop",transitions:c&&{getWidth:c.getLineWidth,getColor:c.getLineColor,getPath:c.getPolygon},getColor:this.getSubLayerAccessor(m),getWidth:this.getSubLayerAccessor(L),getDashArray:this.getSubLayerAccessor(P)},this.getSubLayerProps({id:"stroke",updateTriggers:w&&{getWidth:w.getLineWidth,getColor:w.getLineColor,getDashArray:w.getLineDashArray}}),{data:S,positionFormat:g,getPath:t=>t.path}),o&&I]}}B.layerName="PolygonLayer",B.defaultProps=k;const j=B},6570:t=>{function e(t,e,n){n=n||2;var r,s,a,l,h,d,u,f=e&&e.length,v=f?e[0]*n:t.length,y=i(t,0,v,n,!0),x=[];if(!y||y.next===y.prev)return x;if(f&&(y=function(t,e,n,o){var r,s,a,l=[];for(r=0,s=e.length;r<s;r++)(a=i(t,e[r]*o,r<s-1?e[r+1]*o:t.length,o,!1))===a.next&&(a.steiner=!0),l.push(p(a));for(l.sort(c),r=0;r<l.length;r++)n=g(l[r],n);return n}(t,e,y,n)),t.length>80*n){r=a=t[0],s=l=t[1];for(var m=n;m<v;m+=n)(h=t[m])<r&&(r=h),(d=t[m+1])<s&&(s=d),h>a&&(a=h),d>l&&(l=d);u=0!==(u=Math.max(a-r,l-s))?32767/u:0}return o(y,x,n,r,s,u,0),x}function i(t,e,i,n,o){var r,s;if(o===S(t,e,i,n)>0)for(r=e;r<i;r+=n)s=C(r,t[r],t[r+1],s);else for(r=i-n;r>=e;r-=n)s=C(r,t[r],t[r+1],s);return s&&y(s,s.next)&&(w(s),s=s.next),s}function n(t,e){if(!t)return t;e||(e=t);var i,n=t;do{if(i=!1,n.steiner||!y(n,n.next)&&0!==v(n.prev,n,n.next))n=n.next;else{if(w(n),(n=e=n.prev)===n.next)break;i=!0}}while(i||n!==e);return e}function o(t,e,i,c,g,h,p){if(t){!p&&h&&function(t,e,i,n){var o=t;do{0===o.z&&(o.z=d(o.x,o.y,e,i,n)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==t);o.prevZ.nextZ=null,o.prevZ=null,function(t){var e,i,n,o,r,s,a,l,c=1;do{for(i=t,t=null,r=null,s=0;i;){for(s++,n=i,a=0,e=0;e<c&&(a++,n=n.nextZ);e++);for(l=c;a>0||l>0&&n;)0!==a&&(0===l||!n||i.z<=n.z)?(o=i,i=i.nextZ,a--):(o=n,n=n.nextZ,l--),r?r.nextZ=o:t=o,o.prevZ=r,r=o;i=n}r.nextZ=null,c*=2}while(s>1)}(o)}(t,c,g,h);for(var u,f,v=t;t.prev!==t.next;)if(u=t.prev,f=t.next,h?s(t,c,g,h):r(t))e.push(u.i/i|0),e.push(t.i/i|0),e.push(f.i/i|0),w(t),t=f.next,v=f.next;else if((t=f)===v){p?1===p?o(t=a(n(t),e,i),e,i,c,g,h,2):2===p&&l(t,e,i,c,g,h):o(n(t),e,i,c,g,h,1);break}}}function r(t){var e=t.prev,i=t,n=t.next;if(v(e,i,n)>=0)return!1;for(var o=e.x,r=i.x,s=n.x,a=e.y,l=i.y,c=n.y,g=o<r?o<s?o:s:r<s?r:s,h=a<l?a<c?a:c:l<c?l:c,d=o>r?o>s?o:s:r>s?r:s,p=a>l?a>c?a:c:l>c?l:c,f=n.next;f!==e;){if(f.x>=g&&f.x<=d&&f.y>=h&&f.y<=p&&u(o,a,r,l,s,c,f.x,f.y)&&v(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function s(t,e,i,n){var o=t.prev,r=t,s=t.next;if(v(o,r,s)>=0)return!1;for(var a=o.x,l=r.x,c=s.x,g=o.y,h=r.y,p=s.y,f=a<l?a<c?a:c:l<c?l:c,y=g<h?g<p?g:p:h<p?h:p,x=a>l?a>c?a:c:l>c?l:c,m=g>h?g>p?g:p:h>p?h:p,L=d(f,y,e,i,n),P=d(x,m,e,i,n),_=t.prevZ,C=t.nextZ;_&&_.z>=L&&C&&C.z<=P;){if(_.x>=f&&_.x<=x&&_.y>=y&&_.y<=m&&_!==o&&_!==s&&u(a,g,l,h,c,p,_.x,_.y)&&v(_.prev,_,_.next)>=0)return!1;if(_=_.prevZ,C.x>=f&&C.x<=x&&C.y>=y&&C.y<=m&&C!==o&&C!==s&&u(a,g,l,h,c,p,C.x,C.y)&&v(C.prev,C,C.next)>=0)return!1;C=C.nextZ}for(;_&&_.z>=L;){if(_.x>=f&&_.x<=x&&_.y>=y&&_.y<=m&&_!==o&&_!==s&&u(a,g,l,h,c,p,_.x,_.y)&&v(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;C&&C.z<=P;){if(C.x>=f&&C.x<=x&&C.y>=y&&C.y<=m&&C!==o&&C!==s&&u(a,g,l,h,c,p,C.x,C.y)&&v(C.prev,C,C.next)>=0)return!1;C=C.nextZ}return!0}function a(t,e,i){var o=t;do{var r=o.prev,s=o.next.next;!y(r,s)&&x(r,o,o.next,s)&&P(r,s)&&P(s,r)&&(e.push(r.i/i|0),e.push(o.i/i|0),e.push(s.i/i|0),w(o),w(o.next),o=t=s),o=o.next}while(o!==t);return n(o)}function l(t,e,i,r,s,a){var l=t;do{for(var c=l.next.next;c!==l.prev;){if(l.i!==c.i&&f(l,c)){var g=_(l,c);return l=n(l,l.next),g=n(g,g.next),o(l,e,i,r,s,a,0),void o(g,e,i,r,s,a,0)}c=c.next}l=l.next}while(l!==t)}function c(t,e){return t.x-e.x}function g(t,e){var i=function(t,e){var i,n=e,o=t.x,r=t.y,s=-1/0;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){var a=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(a<=o&&a>s&&(s=a,i=n.x<n.next.x?n:n.next,a===o))return i}n=n.next}while(n!==e);if(!i)return null;var l,c=i,g=i.x,d=i.y,p=1/0;n=i;do{o>=n.x&&n.x>=g&&o!==n.x&&u(r<d?o:s,r,g,d,r<d?s:o,r,n.x,n.y)&&(l=Math.abs(r-n.y)/(o-n.x),P(n,t)&&(l<p||l===p&&(n.x>i.x||n.x===i.x&&h(i,n)))&&(i=n,p=l)),n=n.next}while(n!==c);return i}(t,e);if(!i)return e;var o=_(i,t);return n(o,o.next),n(i,i.next)}function h(t,e){return v(t.prev,t,e.prev)<0&&v(e.next,t,t.next)<0}function d(t,e,i,n,o){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function p(t){var e=t,i=t;do{(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next}while(e!==t);return i}function u(t,e,i,n,o,r,s,a){return(o-s)*(e-a)>=(t-s)*(r-a)&&(t-s)*(n-a)>=(i-s)*(e-a)&&(i-s)*(r-a)>=(o-s)*(n-a)}function f(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&x(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}(t,e)&&(P(t,e)&&P(e,t)&&function(t,e){var i=t,n=!1,o=(t.x+e.x)/2,r=(t.y+e.y)/2;do{i.y>r!=i.next.y>r&&i.next.y!==i.y&&o<(i.next.x-i.x)*(r-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next}while(i!==t);return n}(t,e)&&(v(t.prev,t,e.prev)||v(t,e.prev,e))||y(t,e)&&v(t.prev,t,t.next)>0&&v(e.prev,e,e.next)>0)}function v(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function y(t,e){return t.x===e.x&&t.y===e.y}function x(t,e,i,n){var o=L(v(t,e,i)),r=L(v(t,e,n)),s=L(v(i,n,t)),a=L(v(i,n,e));return o!==r&&s!==a||(!(0!==o||!m(t,i,e))||(!(0!==r||!m(t,n,e))||(!(0!==s||!m(i,t,n))||!(0!==a||!m(i,e,n)))))}function m(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function L(t){return t>0?1:t<0?-1:0}function P(t,e){return v(t.prev,t,t.next)<0?v(t,e,t.next)>=0&&v(t,t.prev,e)>=0:v(t,e,t.prev)<0||v(t,t.next,e)<0}function _(t,e){var i=new b(t.i,t.x,t.y),n=new b(e.i,e.x,e.y),o=t.next,r=e.prev;return t.next=e,e.prev=t,i.next=o,o.prev=i,n.next=i,i.prev=n,r.next=n,n.prev=r,n}function C(t,e,i,n){var o=new b(t,e,i);return n?(o.next=n.next,o.prev=n,n.next.prev=o,n.next=o):(o.prev=o,o.next=o),o}function w(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function b(t,e,i){this.i=t,this.x=e,this.y=i,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function S(t,e,i,n){for(var o=0,r=e,s=i-n;r<i;r+=n)o+=(t[s]-t[r])*(t[r+1]+t[s+1]),s=r;return o}t.exports=e,t.exports.default=e,e.deviation=function(t,e,i,n){var o=e&&e.length,r=o?e[0]*i:t.length,s=Math.abs(S(t,0,r,i));if(o)for(var a=0,l=e.length;a<l;a++){var c=e[a]*i,g=a<l-1?e[a+1]*i:t.length;s-=Math.abs(S(t,c,g,i))}var h=0;for(a=0;a<n.length;a+=3){var d=n[a]*i,p=n[a+1]*i,u=n[a+2]*i;h+=Math.abs((t[d]-t[u])*(t[p+1]-t[d+1])-(t[d]-t[p])*(t[u+1]-t[d+1]))}return 0===s&&0===h?0:Math.abs((h-s)/s)},e.flatten=function(t){for(var e=t[0][0].length,i={vertices:[],holes:[],dimensions:e},n=0,o=0;o<t.length;o++){for(var r=0;r<t[o].length;r++)for(var s=0;s<e;s++)i.vertices.push(t[o][r][s]);o>0&&(n+=t[o-1].length,i.holes.push(n))}return i}},6875:(t,e,i)=>{i.d(e,{x:()=>s});var n=i(9749);const o="precision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n";var r;!function(t){t[t.POINT=0]="POINT",t[t.DIRECTIONAL=1]="DIRECTIONAL"}(r||(r={}));const s={props:{},uniforms:{},name:"lighting",defines:{MAX_LIGHTS:3},uniformTypes:{enabled:"i32",lightType:"i32",directionalLightCount:"i32",pointLightCount:"i32",ambientLightColor:"vec3<f32>",lightColor0:"vec3<f32>",lightPosition0:"vec3<f32>",lightDirection0:"vec3<f32>",lightAttenuation0:"vec3<f32>",lightColor1:"vec3<f32>",lightPosition1:"vec3<f32>",lightDirection1:"vec3<f32>",lightAttenuation1:"vec3<f32>",lightColor2:"vec3<f32>",lightPosition2:"vec3<f32>",lightDirection2:"vec3<f32>",lightAttenuation2:"vec3<f32>"},defaultUniforms:{enabled:1,lightType:r.POINT,directionalLightCount:0,pointLightCount:0,ambientLightColor:[.1,.1,.1],lightColor0:[1,1,1],lightPosition0:[1,1,2],lightDirection0:[1,1,1],lightAttenuation0:[1,0,0],lightColor1:[1,1,1],lightPosition1:[1,1,2],lightDirection1:[1,1,1],lightAttenuation1:[1,0,0],lightColor2:[1,1,1],lightPosition2:[1,1,2],lightDirection2:[1,1,1],lightAttenuation2:[1,0,0]},source:"// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  pointLightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n",vs:o,fs:o,getUniforms:function(t,e={}){if(!(t=t?{...t}:t))return{...s.defaultUniforms};t.lights&&(t={...t,...l(t.lights),lights:void 0});const{ambientLight:i,pointLights:n,directionalLights:o}=t||{};if(!(i||n&&n.length>0||o&&o.length>0))return{...s.defaultUniforms,enabled:0};const r={...s.defaultUniforms,...e,...a({ambientLight:i,pointLights:n,directionalLights:o})};void 0!==t.enabled&&(r.enabled=t.enabled?1:0);return r}};function a({ambientLight:t,pointLights:e=[],directionalLights:i=[]}){const o={};o.ambientLightColor=c(t);let s=0;for(const n of e){o.lightType=r.POINT;const t=s;o[`lightColor${t}`]=c(n),o[`lightPosition${t}`]=n.position,o[`lightAttenuation${t}`]=n.attenuation||[1,0,0],s++}for(const n of i){o.lightType=r.DIRECTIONAL;const t=s;o[`lightColor${t}`]=c(n),o[`lightDirection${t}`]=n.direction,s++}return s>3&&n.R.warn("MAX_LIGHTS exceeded")(),o.directionalLightCount=i.length,o.pointLightCount=e.length,o}function l(t){const e={pointLights:[],directionalLights:[]};for(const i of t||[])switch(i.type){case"ambient":e.ambientLight=i;break;case"directional":e.directionalLights?.push(i);break;case"point":e.pointLights?.push(i)}return e}function c(t={}){const{color:e=[0,0,0],intensity:i=1}=t;return e.map((t=>t*i/255))}}}]);