"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7934],{2478:(e,n,i)=>{i.d(n,{A:()=>h});var t=i(6540),s=i(3908);const o="undefined"!=typeof window?t.useLayoutEffect:t.useEffect;function r(e,n){for(;e;){if(e===n)return!0;e=Object.getPrototypeOf(e)}return!1}var a=i(2130),l=i(9777);const c={position:"absolute",zIndex:-1};function d(e,n){if("function"==typeof e)return e(n);if(Array.isArray(e))return e.map((e=>d(e,n)));if(u(e)){if(i=e,i.props?.mapStyle)return n.style=c,(0,t.cloneElement)(e,n);if(function(e){const n=e.type;return n&&n.deckGLViewProps}(e))return(0,t.cloneElement)(e,n)}var i;return e}function u(e){return e&&"object"==typeof e&&"type"in e||!1}function p(e){if("function"==typeof e)return(0,t.createElement)(a.A,{},e);if(Array.isArray(e))return e.map(p);if(u(e)){if(e.type===t.Fragment)return p(e.props.children);if(r(e.type,a.A))return e}return e}const f=(0,t.createContext)();const g={mixBlendMode:null};function v(e){e.redrawReason&&(e.deck._drawLayers(e.redrawReason),e.redrawReason=null)}const y=t.forwardRef((function(e,n){const[i,c]=(0,t.useState)(0),y=(0,t.useRef)({control:null,version:i,forceUpdate:()=>c((e=>e+1))}).current,h=(0,t.useRef)(null),P=(0,t.useRef)(null),C=(0,t.useMemo)((()=>function({children:e,layers:n=[],views:i=null}){const s=[],o=[],c={};return t.Children.forEach(p(e),(e=>{if(u(e)){const n=e.type;if(r(n,l.A)){const i=function(e,n){const i={},t=e.defaultProps||{};for(const s in n)t[s]!==n[s]&&(i[s]=n[s]);return new e(i)}(n,e.props);o.push(i)}else s.push(e);if(r(n,a.A)&&n!==a.A&&e.props.id){const i=new n(e.props);c[i.id]=i}}else e&&s.push(e)})),Object.keys(c).length>0&&(Array.isArray(i)?i.forEach((e=>{c[e.id]=e})):i&&(c[i.id]=i),i=Object.values(c)),{layers:n=o.length>0?[...o,...n]:n,children:s,views:i}}(e)),[e.layers,e.views,e.children]);let x=!0;const m=n=>x&&e.viewState?(y.viewStateUpdateRequested=n,null):(y.viewStateUpdateRequested=null,e.onViewStateChange?.(n)),L=n=>{x?y.interactionStateUpdateRequested=n:(y.interactionStateUpdateRequested=null,e.onInteractionStateChange?.(n))},_=(0,t.useMemo)((()=>{const n={widgets:[],...e,style:null,width:"100%",height:"100%",parent:h.current,canvas:P.current,layers:C.layers,views:C.views,onViewStateChange:m,onInteractionStateChange:L};return delete n._customRender,y.deck&&y.deck.setProps(n),n}),[e]);(0,t.useEffect)((()=>{const n=e.Deck||s.A;return y.deck=function(e,n,i){const t=new n({...i,_customRender:"webgpu"===i.deviceProps?.adapters?.[0]?.type?void 0:n=>{e.redrawReason=n;const i=t.getViewports();e.lastRenderedViewports!==i?e.forceUpdate():v(e)}});return t}(y,n,{..._,parent:h.current,canvas:P.current}),()=>y.deck?.finalize()}),[]),o((()=>{v(y);const{viewStateUpdateRequested:e,interactionStateUpdateRequested:n}=y;e&&m(e),n&&L(n)})),(0,t.useImperativeHandle)(n,(()=>function(e){return{get deck(){return e.deck},pickObject:n=>e.deck.pickObject(n),pickMultipleObjects:n=>e.deck.pickMultipleObjects(n),pickObjects:n=>e.deck.pickObjects(n)}}(y)),[]);const R=y.deck&&y.deck.isInitialized?y.deck.getViewports():void 0,{ContextProvider:b,width:w="100%",height:k="100%",id:S,style:E}=e,{containerStyle:M,canvasStyle:W}=(0,t.useMemo)((()=>function({width:e,height:n,style:i}){const t={position:"absolute",zIndex:0,left:0,top:0,width:e,height:n},s={left:0,top:0};if(i)for(const o in i)o in g?s[o]=i[o]:t[o]=i[o];return{containerStyle:t,canvasStyle:s}}({width:w,height:k,style:E})),[w,k,E]);if(!y.viewStateUpdateRequested&&y.lastRenderedViewports===R||y.version!==i){y.lastRenderedViewports=R,y.version=i;const e=function({children:e,deck:n,ContextProvider:i=f.Provider}){const{viewManager:s}=n||{};if(!s||!s.views.length)return[];const o={},l=s.views[0].id;for(const t of e){let e=l,n=t;u(t)&&r(t.type,a.A)&&(e=t.props.id||l,n=t.props.children);const i=s.getViewport(e),c=s.getViewState(e);if(i){c.padding=i.padding;const{x:t,y:s,width:r,height:a}=i;n=d(n,{x:t,y:s,width:r,height:a,viewport:i,viewState:c}),o[e]||(o[e]={viewport:i,children:[]}),o[e].children.push(n)}}return Object.keys(o).map((e=>{const{viewport:s,children:r}=o[e],{x:a,y:l,width:c,height:d}=s,u={position:"absolute",left:a,top:l,width:c,height:d},p=`view-${e}`,f=(0,t.createElement)("div",{key:p,id:p,style:u},...r),g={deck:n,viewport:s,container:n.canvas.offsetParent,eventManager:n.eventManager,onViewStateChange:i=>{i.viewId=e,n._onViewStateChange(i)},widgets:[]},v=`view-${e}-context`;return(0,t.createElement)(i,{key:v,value:g},f)}))}({children:C.children,deck:y.deck,ContextProvider:b}),n=(0,t.createElement)("canvas",{key:"canvas",id:S||"deckgl-overlay",ref:P,style:W});y.control=(0,t.createElement)("div",{id:`${S||"deckgl"}-wrapper`,ref:h,style:M},[n,e])}return x=!1,y.control})),h=y},3537:(e,n,i)=>{i.d(n,{A:()=>g});var t=i(9777),s=i(2101),o=i(4411),r=i(6704),a=i(5597),l=i(3391);const c="uniform scatterplotUniforms {\n  float radiusScale;\n  float radiusMinPixels;\n  float radiusMaxPixels;\n  float lineWidthScale;\n  float lineWidthMinPixels;\n  float lineWidthMaxPixels;\n  float stroked;\n  float filled;\n  bool antialiasing;\n  bool billboard;\n  highp int radiusUnits;\n  highp int lineWidthUnits;\n} scatterplot;\n",d={name:"scatterplot",vs:c,fs:c,source:"",uniformTypes:{radiusScale:"f32",radiusMinPixels:"f32",radiusMaxPixels:"f32",lineWidthScale:"f32",lineWidthMinPixels:"f32",lineWidthMaxPixels:"f32",stroked:"f32",filled:"f32",antialiasing:"f32",billboard:"f32",radiusUnits:"i32",lineWidthUnits:"i32"}},u=[0,0,0,255],p={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:u},getLineColor:{type:"accessor",value:u},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class f extends t.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),\nscatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),\nscatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n);\nouterRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\nfloat edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;\nif (scatterplot.billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = scatterplot.antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (scatterplot.stroked > 0.5) {\nfloat isLine = scatterplot.antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (scatterplot.filled > 0.5) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (scatterplot.filled < 0.5) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",source:'// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)\n\nstruct LayerUniforms {\n  opacity: f32,\n};\n\nvar<private> layer: LayerUniforms = LayerUniforms(1.0);\n// @group(0) @binding(1) var<uniform> layer: LayerUniforms;\n\n// Main shaders\n\nstruct ScatterplotUniforms {\n  radiusScale: f32,\n  radiusMinPixels: f32,\n  radiusMaxPixels: f32,\n  lineWidthScale: f32,\n  lineWidthMinPixels: f32,\n  lineWidthMaxPixels: f32,\n  stroked: f32,\n  filled: i32,\n  antialiasing: i32,\n  billboard: i32,\n  radiusUnits: i32,\n  lineWidthUnits: i32,\n};\n\nstruct ConstantAttributeUniforms {\n instancePositions: vec3<f32>,\n instancePositions64Low: vec3<f32>,\n instanceRadius: f32,\n instanceLineWidths: f32,\n instanceFillColors: vec4<f32>,\n instanceLineColors: vec4<f32>,\n instancePickingColors: vec3<f32>,\n\n instancePositionsConstant: i32,\n instancePositions64LowConstant: i32,\n instanceRadiusConstant: i32,\n instanceLineWidthsConstant: i32,\n instanceFillColorsConstant: i32,\n instanceLineColorsConstant: i32,\n instancePickingColorsConstant: i32\n};\n\n@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;\n\nstruct ConstantAttributes {\n  instancePositions: vec3<f32>,\n  instancePositions64Low: vec3<f32>,\n  instanceRadius: f32,\n  instanceLineWidths: f32,\n  instanceFillColors: vec4<f32>,\n  instanceLineColors: vec4<f32>,\n  instancePickingColors: vec3<f32>\n};\n\nconst constants = ConstantAttributes(\n  vec3<f32>(0.0),\n  vec3<f32>(0.0),\n  0.0,\n  0.0,\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec3<f32>(0.0)\n);\n\nstruct Attributes {\n  @builtin(instance_index) instanceIndex : u32,\n  @builtin(vertex_index) vertexIndex : u32,\n  @location(0) positions: vec3<f32>,\n  @location(1) instancePositions: vec3<f32>,\n  @location(2) instancePositions64Low: vec3<f32>,\n  @location(3) instanceRadius: f32,\n  @location(4) instanceLineWidths: f32,\n  @location(5) instanceFillColors: vec4<f32>,\n  @location(6) instanceLineColors: vec4<f32>,\n  @location(7) instancePickingColors: vec3<f32>\n};\n\nstruct Varyings {\n  @builtin(position) position: vec4<f32>,\n  @location(0) vFillColor: vec4<f32>,\n  @location(1) vLineColor: vec4<f32>,\n  @location(2) unitPosition: vec2<f32>,\n  @location(3) innerUnitRadius: f32,\n  @location(4) outerRadiusPixels: f32,\n};\n\n@vertex\nfn vertexMain(attributes: Attributes) -> Varyings {\n  var varyings: Varyings;\n\n  // Draw an inline geometry constant array clip space triangle to verify that rendering works.\n  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  // if (attributes.instanceIndex == 0) {\n  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);\n  //   return varyings;\n  // }\n\n  // var geometry: Geometry;\n  // geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  varyings.outerRadiusPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),\n    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n  );\n\n  // Multiply out line width and clamp to limits\n  let lineWidthPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),\n    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\n  // Expand geometry to accommodate edge smoothing\n  let edgePadding = select(\n    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,\n    1.0,\n    scatterplot.antialiasing != 0\n  );\n\n  // position on the containing square in [-1, 1] space\n  varyings.unitPosition = edgePadding * attributes.positions.xy;\n  geometry.uv = varyings.unitPosition;\n  geometry.pickingColor = attributes.instancePickingColors;\n\n  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;\n\n  if (scatterplot.billboard != 0) {\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    let clipPixels = project_pixel_size_to_clipspace(offset.xy);\n    varyings.position.x = clipPixels.x;\n    varyings.position.y = clipPixels.y;\n  } else {\n    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n  }\n\n  // Apply opacity to instance color, or return instance picking color\n  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);\n  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);\n\n  return varyings;\n}\n\n@fragment\nfn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {\n  // var geometry: Geometry;\n  // geometry.uv = unitPosition;\n\n  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;\n  let inCircle = select(\n    smoothedge(distToCenter, varyings.outerRadiusPixels),\n    step(distToCenter, varyings.outerRadiusPixels),\n    scatterplot.antialiasing != 0\n  );\n\n  if (inCircle == 0.0) {\n    // discard;\n  }\n\n  var fragColor: vec4<f32>;\n\n  if (scatterplot.stroked != 0) {\n    let isLine = select(\n      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      scatterplot.antialiasing != 0\n    );\n\n    if (scatterplot.filled != 0) {\n      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        // discard;\n      }\n      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);\n    }\n  } else if (scatterplot.filled == 0) {\n    // discard;\n  } else {\n    fragColor = varyings.vFillColor;\n  }\n\n  fragColor.a *= inCircle;\n  // DECKGL_FILTER_COLOR(fragColor, geometry);\n\n  return fragColor;\n  // return vec4<f32>(0, 0, 1, 1);\n}\n',modules:[s.A,o.A,d]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e),e.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){const{radiusUnits:n,radiusScale:i,radiusMinPixels:t,radiusMaxPixels:s,stroked:o,filled:a,billboard:l,antialiasing:c,lineWidthUnits:d,lineWidthScale:u,lineWidthMinPixels:p,lineWidthMaxPixels:f}=this.props,g={stroked:o,filled:a,billboard:l,antialiasing:c,radiusUnits:r.p5[n],radiusScale:i,radiusMinPixels:t,radiusMaxPixels:s,lineWidthUnits:r.p5[d],lineWidthScale:u,lineWidthMinPixels:p,lineWidthMaxPixels:f},v=this.state.model;v.shaderInputs.setProps({scatterplot:g}),v.draw(this.context.renderPass)}_getModel(){return new a.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new l.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,-1,1,0,1,1,0])}}}),isInstanced:!0})}}f.defaultProps=p,f.layerName="ScatterplotLayer";const g=f}}]);